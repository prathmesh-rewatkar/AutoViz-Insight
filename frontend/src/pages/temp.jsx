import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
  ResponsiveContainer,
  BarChart, Bar, LineChart, Line, ScatterChart, Scatter,
  XAxis, YAxis, CartesianGrid, Tooltip, Legend,
  ErrorBar,
} from 'recharts';

const groupBy = (data, key) => {
  if (!data || !Array.isArray(data)) return {};
  return data.reduce((acc, item) => {
    const groupKey = item[key];
    if (groupKey !== undefined && groupKey !== null) {
      if (!acc[groupKey]) {
        acc[groupKey] = [];
      }
      acc[groupKey].push(item);
    }
    return acc;
  }, {});
};

const aggregate = (group, feature, aggregation) => {
  if (!group || !Array.isArray(group) || group.length === 0) return null;
  const values = group.map(item => item[feature]).filter(v => typeof v === 'number' && !isNaN(v));

  if (values.length === 0) {
    if (aggregation === 'count') return group.length;
    return null;
  }

  switch (aggregation) {
    case 'sum':
      return values.reduce((a, b) => a + b, 0);
    case 'count':
      return group.length;
    case 'avg':
      return values.reduce((a, b) => a + b, 0) / values.length;
    case 'min':
      return Math.min(...values);
    case 'max':
      return Math.max(...values);
    case 'median':
      values.sort((a, b) => a - b);
      const mid = Math.floor(values.length / 2);
      return values.length % 2 === 0 ? (values[mid - 1] + values[mid]) / 2 : values[mid];
    case 'q1':
      values.sort((a, b) => a - b);
      const q1Index = Math.floor(values.length / 4);
      return values[q1Index];
    case 'q3':
      values.sort((a, b) => a - b);
      const q3Index = Math.ceil(values.length * 3 / 4) - 1;
      return values[q3Index];
    default:
      return null;
  }
};

const binData = (data, feature, numBins = 10) => {
  if (!data || !Array.isArray(data) || data.length === 0) return [];
  const values = data.map(item => item[feature]).filter(v => typeof v === 'number' && !isNaN(v));
  if (values.length === 0) return [];

  const min = Math.min(...values);
  const max = Math.max(...values);
  const range = max - min;
  if (range === 0) {
    return [{ bin: `${min}`, count: values.length }];
  }
  const binSize = range / numBins;

  const bins = Array.from({ length: numBins }, (_, i) => ({
    bin: `${(min + i * binSize).toFixed(2)} - ${(min + (i + 1) * binSize).toFixed(2)}`,
    count: 0,
    minVal: min + i * binSize,
    maxVal: min + (i + 1) * binSize,
  }));

  values.forEach(value => {
    let binIndex = Math.floor((value - min) / binSize);
    if (binIndex >= numBins) binIndex = numBins - 1;
    if (binIndex < 0) binIndex = 0;
    bins[binIndex].count++;
  });

  return bins.filter(b => b.count > 0);
};

const COLORS = ['#8884d8', '#82ca9d', '#ffc658', '#ff7300', '#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#A28DFF', '#FF6B6B'];

const DATASET_ENDPOINT = 'http://127.0.0.1:8000/api/analysis/dataset/34';
const REFETCH_INTERVAL = 100000;

const DASHBOARD_SPEC = {
  "graphs": [
    { "title": "Total Transfer Fees Generated by Selling Team", "graph_type": "bar chart(columns)", "x_axis": { "feature": "from_team_name", "aggregation": "none", "bin_size": null, "label": "Selling Team" }, "y_axis": { "feature": "transfer_fee", "aggregation": "sum", "label": "Total Transfer Fee" }, "group_by": null, "filters": [], "color_scheme": null, "additional_params": { "stacked": false, "normalized": false, "show_trendline": false, "bins": null } },
    { "title": "Total Transfer Fees by Transfer Type", "graph_type": "bar chart(columns)", "x_axis": { "feature": "transfer_type", "aggregation": "none", "bin_size": null, "label": "Transfer Type" }, "y_axis": { "feature": "transfer_fee", "aggregation": "sum", "label": "Total Transfer Fee" }, "group_by": null, "filters": [], "color_scheme": null, "additional_params": { "stacked": false, "normalized": false, "show_trendline": false, "bins": null } },
    { "title": "Total Transfer Fees Over Seasons", "graph_type": "line chart", "x_axis": { "feature": "season_name", "aggregation": "none", "bin_size": null, "label": "Season" }, "y_axis": { "feature": "transfer_fee", "aggregation": "sum", "label": "Total Transfer Fee" }, "group_by": null, "filters": [], "color_scheme": null, "additional_params": { "stacked": false, "normalized": false, "show_trendline": false, "bins": null } },
    { "title": "Transfer Fee vs. Value at Transfer by Type", "graph_type": "scatter chart", "x_axis": { "feature": "transfer_fee", "aggregation": "none", "bin_size": null, "label": "Transfer Fee" }, "y_axis": { "feature": "value_at_transfer", "aggregation": "none", "bin_size": null, "label": "Value at Transfer" }, "group_by": "transfer_type", "filters": [], "color_scheme": "category10", "additional_params": { "stacked": false, "normalized": false, "show_trendline": true, "bins": null } },
    { "title": "Distribution of Transfer Fees by Transfer Type", "graph_type": "box plot", "x_axis": { "feature": "transfer_type", "aggregation": "none", "bin_size": null, "label": "Transfer Type" }, "y_axis": { "feature": "transfer_fee", "aggregation": "none", "bin_size": null, "label": "Transfer Fee" }, "group_by": null, "filters": [], "color_scheme": null, "additional_params": { "stacked": false, "normalized": false, "show_trendline": false, "bins": null } },
    { "title": "Number of Transfers by Selling Team", "graph_type": "bar chart(columns)", "x_axis": { "feature": "from_team_name", "aggregation": "none", "bin_size": null, "label": "Selling Team" }, "y_axis": { "feature": "player_id", "aggregation": "count", "label": "Number of Transfers" }, "group_by": null, "filters": [], "color_scheme": null, "additional_params": { "stacked": false, "normalized": false, "show_trendline": false, "bins": null } }
  ]
};

const DATASET_SCHEMA = {
  "dataset": {
    "endpoint": "https://api.example.com/data/sales",
    "method": "GET",
    "columns": [
      { "name": "player_id", "type": "int64" },
      { "name": "season_name", "type": "object" },
      { "name": "transfer_date", "type": "object" },
      { "name": "from_team_id", "type": "int64" },
      { "name": "from_team_name", "type": "object" },
      { "name": "to_team_id", "type": "int64" },
      { "name": "to_team_name", "type": "object" },
      { "name": "transfer_type", "type": "object" },
      { "name": "value_at_transfer", "type": "int64" },
      { "name": "transfer_fee", "type": "int64" }
    ]
  }
};

const getColumnType = (columnName) => {
  const column = DATASET_SCHEMA.dataset.columns.find(col => col.name === columnName);
  return column ? column.type : null;
};

const isTimeAxis = (feature) => {
  const type = getColumnType(feature);
  return (type === 'object' && (feature.toLowerCase().includes('date') || feature.toLowerCase().includes('time')));
};

const AutoVizDashboard = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(DATASET_ENDPOINT);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const result = await response.json();
      setData(result);
    } catch (e) {
      setError(e.message);
      setData(null);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
    const intervalId = setInterval(fetchData, REFETCH_INTERVAL);
    return () => clearInterval(intervalId);
  }, [fetchData]);

  const processedCharts = useMemo(() => {
    if (!data || !Array.isArray(data) || data.length === 0) return [];

    return DASHBOARD_SPEC.graphs.map((spec, index) => {
      try {
        const { x_axis, y_axis, group_by, graph_type, title, additional_params } = spec;
        const xFeature = x_axis.feature;
        const yFeature = y_axis.feature;
        const yAggregation = y_axis.aggregation;
        const isStacked = additional_params?.stacked || false;

        let chartData = [];
        let chartType = null;
        let xType = 'category';
        if (isTimeAxis(xFeature)) {
          xType = 'time';
        } else if (getColumnType(xFeature) === 'int64' || getColumnType(xFeature) === 'float64') {
          xType = 'number';
        }

        const parsedData = data.map(item => {
          const newItem = { ...item };
          if (xType === 'time' && item[xFeature]) {
            try {
              newItem[xFeature] = new Date(item[xFeature]);
              if (isNaN(newItem[xFeature].getTime())) {
                newItem[xFeature] = item[xFeature]; // Fallback to original if parsing fails
                xType = 'category'; // Treat as category if date parsing fails
              }
            } catch (e) {
              newItem[xFeature] = item[xFeature];
              xType = 'category';
            }
          }
          return newItem;
        });

        if (graph_type === 'box plot') {
          const boxPlotData = [];
          const groupedForBoxPlot = groupBy(parsedData, xFeature);
          Object.keys(groupedForBoxPlot).forEach(xVal => {
            const group = groupedForBoxPlot[xVal];
            const values = group.map(item => item[yFeature]).filter(v => typeof v === 'number' && !isNaN(v));
            if (values.length > 0) {
              const min = aggregate(group, yFeature, 'min');
              const max = aggregate(group, yFeature, 'max');
              const median = aggregate(group, yFeature, 'median');
              const q1 = aggregate(group, yFeature, 'q1');
              const q3 = aggregate(group, yFeature, 'q3');
              boxPlotData.push({
                [xFeature]: xType === 'time' ? new Date(xVal) : xVal,
                min, max, median, q1, q3,
              });
            }
          });
          chartData = boxPlotData;
          chartType = 'BoxPlot';
        } else if (group_by) {
          const grouped = groupBy(parsedData, group_by);
          Object.keys(grouped).forEach(groupKey => {
            const group = grouped[groupKey];
            const aggregatedGroup = groupBy(group, xFeature);
            Object.keys(aggregatedGroup).forEach(xVal => {
              const yVal = aggregate(aggregatedGroup[xVal], yFeature, yAggregation);
              if (yVal !== null) {
                chartData.push({
                  [group_by]: groupKey,
                  [xFeature]: xType === 'time' ? new Date(xVal) : xVal,
                  [yFeature]: yVal,
                });
              }
            });
          });
        } else {
          if (yAggregation && yAggregation !== 'none') {
            const aggregatedByX = groupBy(parsedData, xFeature);
            Object.keys(aggregatedByX).forEach(xVal => {
              const yVal = aggregate(aggregatedByX[xVal], yFeature, yAggregation);
              if (yVal !== null) {
                chartData.push({
                  [xFeature]: xType === 'time' ? new Date(xVal) : xVal,
                  [yFeature]: yVal,
                });
              }
            });
          } else {
            chartData = parsedData.map(item => ({
              [xFeature]: xType === 'time' ? new Date(item[xFeature]) : item[xFeature],
              [yFeature]: item[yFeature],
              ...(group_by && { [group_by]: item[group_by] })
            })).filter(item => item[xFeature] !== undefined && item[yFeature] !== undefined && item[xFeature] !== null && item[yFeature] !== null);
          }
        }

        if (graph_type === 'line chart' && xType === 'time') {
          chartData.sort((a, b) => a[xFeature].getTime() - b[xFeature].getTime());
        } else if (graph_type === 'line chart' && getColumnType(xFeature) === 'object') {
          chartData.sort((a, b) => String(a[xFeature]).localeCompare(String(b[xFeature])));
        }

        if (!chartType) {
          if (graph_type.includes('bar chart')) {
            chartType = 'BarChart';
          } else if (graph_type === 'line chart') {
            chartType = 'LineChart';
          } else if (graph_type === 'scatter chart') {
            chartType = 'ScatterChart';
          } else {
            console.warn(`Unsupported chart type: ${graph_type}`);
            return null;
          }
        }

        if (chartData.length === 0) {
          return null;
        }

        return {
          id: `chart-${index}`,
          title,
          chartType,
          data: chartData,
          xFeature,
          yFeature,
          xLabel: x_axis.label,
          yLabel: y_axis.label,
          xType,
          group_by,
          isStacked,
        };
      } catch (e) {
        console.error(`Error processing chart ${spec.title}:`, e);
        return null;
      }
    }).filter(Boolean);
  }, [data]);

  if (loading) {
    return (
      <div style={{
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        minHeight: '100vh',
        fontSize: '24px',
        color: '#555',
        fontFamily: 'Arial, sans-serif'
      }}>
        Loading dashboard data...
      </div>
    );
  }

  if (error) {
    return (
      <div style={{
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        minHeight: '100vh',
        fontSize: '20px',
        color: '#D32F2F',
        fontFamily: 'Arial, sans-serif',
        padding: '20px',
        textAlign: 'center'
      }}>
        <p>Error loading dashboard: {error}</p>
        <p>Please check the data endpoint or network connection.</p>
      </div>
    );
  }

  if (!data || data.length === 0 || processedCharts.length === 0) {
    return (
      <div style={{
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        minHeight: '100vh',
        fontSize: '24px',
        color: '#777',
        fontFamily: 'Arial, sans-serif'
      }}>
        No data available to display charts.
      </div>
    );
  }

  const renderChart = (chartProps) => {
    const { id, title, chartType, data, xFeature, yFeature, xLabel, yLabel, xType, group_by, isStacked } = chartProps;

    const commonChartProps = {
      data: data,
      margin: { top: 20, right: 30, left: 20, bottom: 5 },
    };

    const commonAxisProps = {
      fontSize: 12,
      tickLine: false,
      axisLine: false,
      label: { value: xLabel, position: 'insideBottom', offset: -5, fontSize: 14 },
    };

    const commonYAxisProps = {
      fontSize: 12,
      tickLine: false,
      axisLine: false,
      label: { value: yLabel, angle: -90, position: 'insideLeft', offset: 10, fontSize: 14 },
    };

    const renderXAxis = () => {
      if (xType === 'time') {
        return (
          <XAxis
            dataKey={xFeature}
            type="number"
            scale="time"
            domain={['dataMin', 'dataMax']}
            tickFormatter={(tick) => new Date(tick).toLocaleDateString()}
            {...commonAxisProps}
          />
        );
      }
      return <XAxis dataKey={xFeature} {...commonAxisProps} />;
    };

    if (chartType === 'BarChart') {
      const barKeys = group_by ? Array.from(new Set(data.map(d => d[group_by]))) : [yFeature];
      return (
        <ResponsiveContainer width="100%" height={300}>
          <BarChart {...commonChartProps}>
            <CartesianGrid strokeDasharray="3 3" vertical={false} />
            {renderXAxis()}
            <YAxis {...commonYAxisProps} />
            <Tooltip />
            {group_by && <Legend />}
            {barKeys.map((key, i) => (
              <Bar
                key={key}
                dataKey={group_by ? key : yFeature}
                fill={COLORS[i % COLORS.length]}
                stackId={isStacked ? 'a' : undefined}
              />
            ))}
          </BarChart>
        </ResponsiveContainer>
      );
    } else if (chartType === 'LineChart') {
      const lineKeys = group_by ? Array.from(new Set(data.map(d => d[group_by]))) : [yFeature];
      return (
        <ResponsiveContainer width="100%" height={300}>
          <LineChart {...commonChartProps}>
            <CartesianGrid strokeDasharray="3 3" vertical={false} />
            {renderXAxis()}
            <YAxis {...commonYAxisProps} />
            <Tooltip />
            {group_by && <Legend />}
            {lineKeys.map((key, i) => (
              <Line
                key={key}
                type="monotone"
                dataKey={group_by ? key : yFeature}
                stroke={COLORS[i % COLORS.length]}
                dot={true}
              />
            ))}
          </LineChart>
        </ResponsiveContainer>
      );
    } else if (chartType === 'ScatterChart') {
      const scatterKeys = group_by ? Array.from(new Set(data.map(d => d[group_by]))) : ['series'];
      return (
        <ResponsiveContainer width="100%" height={300}>
          <ScatterChart {...commonChartProps}>
            <CartesianGrid strokeDasharray="3 3" vertical={false} />
            <XAxis
              dataKey={xFeature}
              type="number"
              label={{ value: xLabel, position: 'insideBottom', offset: -5, fontSize: 14 }}
              {...commonAxisProps}
            />
            <YAxis
              dataKey={yFeature}
              type="number"
              label={{ value: yLabel, angle: -90, position: 'insideLeft', offset: 10, fontSize: 14 }}
              {...commonYAxisProps}
            />
            <Tooltip cursor={{ strokeDasharray: '3 3' }} />
            {group_by && <Legend />}
            {scatterKeys.map((key, i) => (
              <Scatter
                key={key}
                name={key}
                data={group_by ? data.filter(d => d[group_by] === key) : data}
                fill={COLORS[i % COLORS.length]}
              />
            ))}
          </ScatterChart>
        </ResponsiveContainer>
      );
    } else if (chartType === 'BoxPlot') {
      return (
        <ResponsiveContainer width="100%" height={300}>
          <BarChart {...commonChartProps}>
            <CartesianGrid strokeDasharray="3 3" vertical={false} />
            {renderXAxis()}
            <YAxis {...commonYAxisProps} />
            <Tooltip />
            <Legend />
            <Bar dataKey="median" fill={COLORS[0]} name="Median">
              <ErrorBar dataKey="min" width={4} strokeWidth={1} stroke={COLORS[0]} direction="y" />
              <ErrorBar dataKey="max" width={4} strokeWidth={1} stroke={COLORS[0]} direction="y" />
            </Bar>
          </BarChart>
        </ResponsiveContainer>
      );
    }
    return null;
  };

  return (
    <div style={{
      fontFamily: 'Arial, sans-serif',
      padding: '20px',
      backgroundColor: '#f9f9f9',
      minHeight: '100vh',
      boxSizing: 'border-box'
    }}>
      <h1 style={{ textAlign: 'center', marginBottom: '30px', color: '#333', fontSize: '28px' }}>
        Dynamic Dashboard
      </h1>
      <div style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(400px, 1fr))',
        gap: '20px',
        justifyContent: 'center',
        alignItems: 'stretch'
      }}>
        {processedCharts.map((chartProps) => (
          <div key={chartProps.id} style={{
            backgroundColor: '#fff',
            borderRadius: '8px',
            boxShadow: '0 2px 10px rgba(0,0,0,0.08)',
            padding: '20px',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            minHeight: '380px',
            boxSizing: 'border-box'
          }}>
            <h3 style={{
              marginBottom: '15px',
              color: '#444',
              fontSize: '18px',
              textAlign: 'center',
              width: '100%'
            }}>
              {chartProps.title}
            </h3>
            {renderChart(chartProps)}
          </div>
        ))}
      </div>
    </div>
  );
};

export default AutoVizDashboard;